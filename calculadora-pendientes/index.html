<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calculadora de Pendientes F√≠sicas - IES Mar√≠a Moliner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            max-width: 900px;
            width: 100%;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 10px;
            font-size: clamp(1.5rem, 4vw, 2rem);
        }

        .subtitle {
            color: rgba(255, 255, 255, 0.9);
            text-align: center;
            margin-bottom: 25px;
            font-size: clamp(0.9rem, 2vw, 1.1rem);
        }

        .context-panel {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 20px;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-bottom: 20px;
            border-left: 4px solid #fbbf24;
        }

        .context-title {
            font-size: clamp(1.1rem, 3vw, 1.3rem);
            font-weight: 700;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .context-description {
            font-size: clamp(0.95rem, 2.5vw, 1.05rem);
            line-height: 1.6;
        }

        .canvas-container {
            background: white;
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        canvas {
            display: block;
            margin: 0 auto;
            cursor: crosshair;
            border: 2px solid #667eea;
            border-radius: 10px;
            max-width: 100%;
            height: auto;
            touch-action: none;
        }

        .controls {
            display: grid;
            gap: 15px;
            margin-bottom: 20px;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 15px;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
            flex-wrap: wrap;
            gap: 10px;
        }

        .info-label {
            font-weight: 600;
            font-size: clamp(0.9rem, 2vw, 1rem);
        }

        .info-value {
            font-family: 'Courier New', monospace;
            background: rgba(255, 255, 255, 0.2);
            padding: 5px 12px;
            border-radius: 6px;
            font-size: clamp(0.85rem, 2vw, 0.95rem);
        }

        .input-panel {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            color: white;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: clamp(0.9rem, 2vw, 1rem);
        }

        input[type="number"] {
            width: 100%;
            padding: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
            background: rgba(255, 255, 255, 0.9);
            transition: all 0.3s;
            min-height: 55px;
            text-align: center;
        }

        input[type="number"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .button-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        button {
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            font-size: clamp(1rem, 3vw, 1.1rem);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            min-height: 50px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .result-panel {
            background: rgba(255, 255, 255, 0.25);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            padding: 20px;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-top: 20px;
            display: none;
            max-height: 70vh;
            overflow-y: auto;
        }

        .result-panel::-webkit-scrollbar {
            width: 8px;
        }

        .result-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .result-panel::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.4);
            border-radius: 4px;
        }

        .result-panel::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.6);
        }

        .result-panel.show {
            display: block;
            animation: slideDown 0.4s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .result-title {
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            font-weight: 700;
            margin-bottom: 12px;
            text-align: center;
        }

        .result-correct {
            border-left: 4px solid #4ade80;
        }

        .result-incorrect {
            border-left: 4px solid #f87171;
        }

        .calculation {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 12px;
            margin: 12px 0;
            text-align: center;
        }

        .math-step {
            background: rgba(255, 255, 255, 0.3);
            padding: 12px;
            margin: 10px 0;
            border-radius: 8px;
            font-size: clamp(0.95rem, 3.5vw, 1.1rem);
            font-weight: 500;
            line-height: 1.8;
        }

        .math-fraction {
            display: inline-flex;
            flex-direction: column;
            vertical-align: middle;
            text-align: center;
            margin: 0 6px;
        }

        .math-numerator {
            border-bottom: 2px solid white;
            padding: 4px 12px;
            min-width: 70px;
            font-size: clamp(0.85rem, 3vw, 1rem);
        }

        .math-denominator {
            padding: 4px 12px;
            min-width: 70px;
            font-size: clamp(0.85rem, 3vw, 1rem);
        }

        .math-equals {
            margin: 0 8px;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
        }

        .step-label {
            font-size: clamp(0.85rem, 2.5vw, 0.95rem);
            opacity: 0.9;
            margin-bottom: 6px;
            font-weight: 600;
        }

        .final-answer {
            background: rgba(255, 255, 255, 0.4);
            padding: 15px;
            margin-top: 12px;
            border-radius: 10px;
            font-size: clamp(1.1rem, 4vw, 1.4rem);
            font-weight: 700;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .instruction {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 8px;
            color: white;
            margin-bottom: 20px;
            border-left: 4px solid #4ade80;
            font-size: clamp(0.85rem, 2vw, 0.95rem);
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            canvas {
                touch-action: none;
            }

            .button-group {
                grid-template-columns: 1fr;
            }

            .canvas-container {
                padding: 10px;
            }

            .info-panel, .input-panel, .result-panel {
                padding: 15px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .subtitle {
                font-size: 0.95rem;
            }
        }

        .footer {
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 20px;
            font-size: clamp(0.8rem, 2vw, 0.9rem);
        }

        .units {
            font-size: 0.85em;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìê Calculadora de Pendientes F√≠sicas</h1>
        <p class="subtitle">Desarrollado por Javier Gij√≥n - Prof. del IES Mar√≠a Moliner (Segovia)</p>

        <div class="context-panel" id="contextPanel">
            <div class="context-title">
                <span id="contextIcon">üöó</span>
                <span id="contextTitleText">Cargando...</span>
            </div>
            <div class="context-description" id="contextDescription"></div>
        </div>

        <div class="instruction">
            <strong>üìå Instrucciones:</strong> Haz clic en DOS puntos sobre la recta para calcular su pendiente. Observa las unidades de las magnitudes f√≠sicas.
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="700" height="500"></canvas>
        </div>

        <div class="controls">
            <div class="info-panel">
                <div class="info-row">
                    <span class="info-label">Puntos seleccionados:</span>
                    <span class="info-value" id="pointCount">0 / 2</span>
                </div>
                <div class="info-row" id="point1Info" style="display: none;">
                    <span class="info-label">Punto 1:</span>
                    <span class="info-value" id="point1Text"></span>
                </div>
                <div class="info-row" id="point2Info" style="display: none;">
                    <span class="info-label">Punto 2:</span>
                    <span class="info-value" id="point2Text"></span>
                </div>
                <div class="info-row" id="deltaInfo" style="display: none;">
                    <span class="info-label" id="deltaXLabel">Œît:</span>
                    <span class="info-value" id="deltaX"></span>
                    <span class="info-label" id="deltaYLabel">Œîv:</span>
                    <span class="info-value" id="deltaY"></span>
                </div>
            </div>

            <div class="input-panel" id="inputPanel" style="display: none;">
                <div class="input-group">
                    <label for="slopeInput" id="slopeQuestion">¬øCu√°l es la pendiente?</label>
                    <input type="number" id="slopeInput" step="0.01" placeholder="Introduce tu respuesta...">
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px;">
                    <button class="btn-success" onclick="checkAnswer()">‚úì Comprobar</button>
                    <button class="btn-secondary" onclick="resetPoints()">‚Ü∫ Reintentar</button>
                </div>
            </div>

            <div class="result-panel" id="resultPanel"></div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <button class="btn-primary" onclick="generateNewScenario()">üé≤ Nuevo Escenario</button>
                <button class="btn-secondary" onclick="resetPoints()">üîÑ Limpiar Puntos</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        let slope = 0;
        let yIntercept = 0;
        let selectedPoints = [];
        let currentScenario = null;
        let showSlopeValue = false;
        let usedScenarios = []; // Para evitar repetir escenarios en la misma sesi√≥n
        
        const CANVAS_WIDTH = 700;
        const CANVAS_HEIGHT = 500;
        const ORIGIN_X = CANVAS_WIDTH / 2;
        const ORIGIN_Y = CANVAS_HEIGHT / 2;
        const SCALE = 30;

        // Escenarios f√≠sicos con restricciones de dominio
        const scenarios = [
            {
                icon: 'üöó',
                title: 'Cinem√°tica: Velocidad vs Tiempo',
                description: 'Un coche se mueve con aceleraci√≥n constante. La gr√°fica muestra c√≥mo var√≠a su velocidad con el tiempo.',
                xVar: 't',
                yVar: 'v',
                xUnit: 's',
                yUnit: 'm/s',
                slopeVar: 'a',
                slopeUnit: 'm/s¬≤',
                slopeName: 'aceleraci√≥n',
                xName: 'tiempo',
                yName: 'velocidad',
                xMin: 0,
                yMin: null,
                xMax: 10,
                yMax: 10,
                slopePositive: false
            },
            {
                icon: 'üìè',
                title: 'Cinem√°tica: Posici√≥n vs Tiempo (MRU)',
                description: 'Un objeto se mueve con velocidad constante. La pendiente representa su velocidad.',
                xVar: 't',
                yVar: 'x',
                xUnit: 's',
                yUnit: 'm',
                slopeVar: 'v',
                slopeUnit: 'm/s',
                slopeName: 'velocidad',
                xName: 'tiempo',
                yName: 'posici√≥n',
                xMin: 0,
                yMin: null,
                xMax: 10,
                yMax: 10,
                slopePositive: false
            },
            {
                icon: 'üîã',
                title: 'Ley de Ohm: Voltaje vs Intensidad',
                description: 'En un circuito el√©ctrico, la relaci√≥n entre el voltaje y la corriente es lineal seg√∫n la Ley de Ohm.',
                xVar: 'I',
                yVar: 'V',
                xUnit: 'A',
                yUnit: 'V',
                slopeVar: 'R',
                slopeUnit: 'Œ©',
                slopeName: 'resistencia',
                xName: 'intensidad',
                yName: 'voltaje',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: '‚öñÔ∏è',
                title: 'Ley de Hooke: Fuerza vs Elongaci√≥n',
                description: 'Un muelle se estira proporcionalmente a la fuerza aplicada. La pendiente es la constante el√°stica.',
                xVar: '(Œîx)',
                yVar: 'F',
                xUnit: 'm',
                yUnit: 'N',
                slopeVar: 'k',
                slopeUnit: 'N/m',
                slopeName: 'constante el√°stica',
                xName: 'elongaci√≥n',
                yName: 'fuerza',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: 'üå°Ô∏è',
                title: 'Calorimetr√≠a: Calor vs Temperatura',
                description: 'Al calentar una sustancia, la cantidad de calor absorbido es proporcional al cambio de temperatura.',
                xVar: '(ŒîT)',
                yVar: 'Q',
                xUnit: '¬∞C',
                yUnit: 'J',
                slopeVar: 'C',
                slopeUnit: 'J/¬∞C',
                slopeName: 'capacidad calor√≠fica',
                xName: 'variaci√≥n de temperatura',
                yName: 'calor',
                xMin: null,
                yMin: null,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: 'üí∞',
                title: 'Econom√≠a: Coste vs Cantidad',
                description: 'El coste total de producci√≥n depende linealmente de la cantidad producida.',
                xVar: 'n',
                yVar: 'C',
                xUnit: 'unidades',
                yUnit: '‚Ç¨',
                slopeVar: 'p',
                slopeUnit: '‚Ç¨/unidad',
                slopeName: 'coste unitario',
                xName: 'cantidad',
                yName: 'coste total',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: '‚ö°',
                title: 'Potencia vs Tiempo',
                description: 'Un dispositivo consume energ√≠a de forma constante. La pendiente representa la potencia.',
                xVar: 't',
                yVar: 'E',
                xUnit: 's',
                yUnit: 'J',
                slopeVar: 'P',
                slopeUnit: 'W',
                slopeName: 'potencia',
                xName: 'tiempo',
                yName: 'energ√≠a',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: 'üß™',
                title: 'Qu√≠mica: Concentraci√≥n vs Volumen',
                description: 'En una diluci√≥n, la cantidad de soluto es proporcional al volumen de disoluci√≥n.',
                xVar: 'V',
                yVar: 'n',
                xUnit: 'L',
                yUnit: 'mol',
                slopeVar: 'M',
                slopeUnit: 'mol/L',
                slopeName: 'concentraci√≥n molar',
                xName: 'volumen',
                yName: 'moles de soluto',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: 'üå°Ô∏è',
                title: 'Gases Ideales: Presi√≥n vs Temperatura',
                description: 'A volumen constante, la presi√≥n de un gas ideal es proporcional a su temperatura absoluta (Ley de Gay-Lussac).',
                xVar: 'T',
                yVar: 'P',
                xUnit: 'K',
                yUnit: 'Pa',
                slopeVar: 'k',
                slopeUnit: 'Pa/K',
                slopeName: 'constante de proporcionalidad',
                xName: 'temperatura',
                yName: 'presi√≥n',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: 'üéà',
                title: 'Gases Ideales: Volumen vs Temperatura',
                description: 'A presi√≥n constante, el volumen de un gas ideal es proporcional a su temperatura absoluta (Ley de Charles).',
                xVar: 'T',
                yVar: 'V',
                xUnit: 'K',
                yUnit: 'L',
                slopeVar: 'k',
                slopeUnit: 'L/K',
                slopeName: 'constante de proporcionalidad',
                xName: 'temperatura',
                yName: 'volumen',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: '‚öóÔ∏è',
                title: 'Densidad: Masa vs Volumen',
                description: 'Para una sustancia homog√©nea, la masa es proporcional al volumen. La pendiente es la densidad.',
                xVar: 'V',
                yVar: 'm',
                xUnit: 'cm¬≥',
                yUnit: 'g',
                slopeVar: 'œÅ',
                slopeUnit: 'g/cm¬≥',
                slopeName: 'densidad',
                xName: 'volumen',
                yName: 'masa',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: 'üíß',
                title: 'Hidrost√°tica: Presi√≥n vs Profundidad',
                description: 'La presi√≥n en un fluido aumenta linealmente con la profundidad.',
                xVar: 'h',
                yVar: 'P',
                xUnit: 'm',
                yUnit: 'Pa',
                slopeVar: 'œÅg',
                slopeUnit: 'Pa/m',
                slopeName: 'gradiente de presi√≥n',
                xName: 'profundidad',
                yName: 'presi√≥n',
                xMin: 0,
                yMin: null,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: 'üî¨',
                title: 'Ley de Hooke (Compresi√≥n): Presi√≥n vs Deformaci√≥n',
                description: 'En un s√≥lido el√°stico, la presi√≥n aplicada es proporcional a la deformaci√≥n volum√©trica.',
                xVar: '(ŒîV/V)',
                yVar: 'P',
                xUnit: '%',
                yUnit: 'Pa',
                slopeVar: 'K',
                slopeUnit: 'Pa/%',
                slopeName: 'm√≥dulo volum√©trico',
                xName: 'deformaci√≥n relativa',
                yName: 'presi√≥n',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: 'üåä',
                title: 'Caudal: Volumen vs Tiempo',
                description: 'El volumen de fluido que pasa por un conducto es proporcional al tiempo. La pendiente es el caudal.',
                xVar: 't',
                yVar: 'V',
                xUnit: 's',
                yUnit: 'L',
                slopeVar: 'Q',
                slopeUnit: 'L/s',
                slopeName: 'caudal',
                xName: 'tiempo',
                yName: 'volumen',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: true
            },
            {
                icon: 'üìª',
                title: 'Ondas: Longitud vs Frecuencia',
                description: 'Para ondas electromagn√©ticas, la longitud de onda es inversamente proporcional a la frecuencia (pendiente negativa).',
                xVar: 'f',
                yVar: 'Œª',
                xUnit: 'Hz',
                yUnit: 'm',
                slopeVar: 'k',
                slopeUnit: 'm¬∑Hz',
                slopeName: 'constante (inversa)',
                xName: 'frecuencia',
                yName: 'longitud de onda',
                xMin: 0,
                yMin: 0,
                xMax: 10,
                yMax: 10,
                slopePositive: false,
                inverseRelation: true
            }
        ];

        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(container.clientWidth - 40, 700);
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = (maxWidth * 500 / 700) + 'px';
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function generateNewScenario() {
            selectedPoints = [];
            showSlopeValue = false;
            updatePointInfo();
            document.getElementById('inputPanel').style.display = 'none';
            document.getElementById('resultPanel').classList.remove('show');
            
            // Si ya se usaron todos los escenarios, reiniciar la lista
            if (usedScenarios.length >= scenarios.length) {
                usedScenarios = [];
            }
            
            // Seleccionar escenario aleatorio que no se haya usado
            let availableScenarios = scenarios.filter((s, index) => !usedScenarios.includes(index));
            let selectedIndex = Math.floor(Math.random() * availableScenarios.length);
            currentScenario = availableScenarios[selectedIndex];
            
            // Marcar como usado
            let globalIndex = scenarios.indexOf(currentScenario);
            usedScenarios.push(globalIndex);
            
            // Actualizar contexto
            document.getElementById('contextIcon').textContent = currentScenario.icon;
            document.getElementById('contextTitleText').textContent = currentScenario.title;
            document.getElementById('contextDescription').textContent = currentScenario.description;
            
            // Actualizar pregunta
            document.getElementById('slopeQuestion').innerHTML = 
                `¬øCu√°l es la ${currentScenario.slopeName}? <span class="units">(${currentScenario.slopeUnit})</span>`;
            
            // Generar pendiente apropiada seg√∫n restricciones
            if (currentScenario.slopePositive) {
                // La pendiente DEBE ser positiva (resistencia, capacidad calor√≠fica, etc.)
                slope = (Math.random() * 1.5 + 0.3).toFixed(2) * 1;
                if (currentScenario.xMin !== null && currentScenario.xMin >= 0 && 
                    currentScenario.yMin !== null && currentScenario.yMin >= 0) {
                    yIntercept = (Math.random() * 2).toFixed(2) * 1;
                } else {
                    yIntercept = (Math.random() * 6 - 3).toFixed(2) * 1;
                }
            } else if (currentScenario.xMin !== null && currentScenario.xMin >= 0 && 
                currentScenario.yMin !== null && currentScenario.yMin >= 0) {
                // Ambas variables deben ser positivas: pendiente positiva y que pase por (0,0) o cerca
                slope = (Math.random() * 1.5 + 0.3).toFixed(2) * 1;
                yIntercept = (Math.random() * 2).toFixed(2) * 1;
            } else if (currentScenario.xMin !== null && currentScenario.xMin >= 0) {
                // Solo x debe ser positivo: pendiente puede ser positiva o negativa
                slope = (Math.random() * 2 - 1).toFixed(2) * 1;
                if (Math.abs(slope) < 0.2) slope = slope < 0 ? -0.5 : 0.5;
                yIntercept = (Math.random() * 6 - 3).toFixed(2) * 1;
            } else {
                // Ambas pueden ser negativas: cualquier pendiente
                slope = (Math.random() * 2 - 1).toFixed(2) * 1;
                if (Math.abs(slope) < 0.2) slope = slope < 0 ? -0.5 : 0.5;
                yIntercept = (Math.random() * 4 - 2).toFixed(2) * 1;
            }
            
            drawGraph();
        }

        function drawGraph() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Fondo
            ctx.fillStyle = '#f8fafc';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Determinar rango de ejes seg√∫n restricciones
            const xMin = currentScenario.xMin !== null ? currentScenario.xMin : -10;
            const xMax = currentScenario.xMax;
            const yMin = currentScenario.yMin !== null ? currentScenario.yMin : -10;
            const yMax = currentScenario.yMax;
            
            // Calcular origen y escala seg√∫n restricciones
            let originX, originY, scaleX, scaleY;
            
            if (currentScenario.xMin !== null && currentScenario.xMin >= 0 && 
                currentScenario.yMin !== null && currentScenario.yMin >= 0) {
                // Ambos positivos: maximizar el espacio √∫til
                originX = 60;  // Margen izquierdo para etiquetas
                originY = CANVAS_HEIGHT - 60;  // Margen inferior para etiquetas
                
                // Escala adaptativa para aprovechar todo el espacio
                const availableWidth = CANVAS_WIDTH - 80;  // Espacio horizontal disponible
                const availableHeight = CANVAS_HEIGHT - 80;  // Espacio vertical disponible
                scaleX = availableWidth / 10;  // 10 unidades en X
                scaleY = availableHeight / 10;  // 10 unidades en Y
            } else if (currentScenario.xMin !== null && currentScenario.xMin >= 0) {
                // Solo X positivo: origen a la izquierda, Y centrado
                originX = 60;
                originY = ORIGIN_Y;
                scaleX = (CANVAS_WIDTH - 80) / 10;
                scaleY = SCALE;
            } else if (currentScenario.yMin !== null && currentScenario.yMin >= 0) {
                // Solo Y positivo: X centrado, origen abajo
                originX = ORIGIN_X;
                originY = CANVAS_HEIGHT - 60;
                scaleX = SCALE;
                scaleY = (CANVAS_HEIGHT - 80) / 10;
            } else {
                // Ambos pueden ser negativos: origen centrado
                originX = ORIGIN_X;
                originY = ORIGIN_Y;
                scaleX = SCALE;
                scaleY = SCALE;
            }
            
            // Cuadr√≠cula
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1;
            
            const gridStartX = currentScenario.xMin !== null && currentScenario.xMin >= 0 ? 0 : -10;
            const gridStartY = currentScenario.yMin !== null && currentScenario.yMin >= 0 ? 0 : -10;
            
            for (let i = gridStartX; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(originX + i * scaleX, 0);
                ctx.lineTo(originX + i * scaleX, CANVAS_HEIGHT);
                ctx.stroke();
            }
            
            for (let i = gridStartY; i <= 10; i++) {
                ctx.beginPath();
                ctx.moveTo(0, originY - i * scaleY);
                ctx.lineTo(CANVAS_WIDTH, originY - i * scaleY);
                ctx.stroke();
            }
            
            // Ejes
            ctx.strokeStyle = '#1e293b';
            ctx.lineWidth = 2;
            
            // Eje X
            ctx.beginPath();
            ctx.moveTo(0, originY);
            ctx.lineTo(CANVAS_WIDTH, originY);
            ctx.stroke();
            
            // Eje Y
            ctx.beginPath();
            ctx.moveTo(originX, 0);
            ctx.lineTo(originX, CANVAS_HEIGHT);
            ctx.stroke();
            
            // Flechas
            drawArrow(CANVAS_WIDTH - 10, originY, 10, 5, 'right');
            drawArrow(originX, 10, 10, 5, 'up');
            
            // Etiquetas de ejes con variables f√≠sicas
            ctx.fillStyle = '#1e293b';
            ctx.font = 'bold 18px Arial';
            const xLabel = `${currentScenario.xVar} (${currentScenario.xUnit})`;
            const yLabel = `${currentScenario.yVar} (${currentScenario.yUnit})`;
            ctx.fillText(xLabel, CANVAS_WIDTH - 90, originY - 15);
            ctx.fillText(yLabel, originX + 15, 25);
            
            // N√∫meros en los ejes
            ctx.font = '12px Arial';
            for (let i = gridStartX; i <= 10; i++) {
                if (i !== 0 || (currentScenario.xMin !== null && currentScenario.xMin >= 0)) {
                    ctx.fillText(i, originX + i * scaleX - 5, originY + 20);
                }
            }
            
            for (let i = gridStartY; i <= 10; i++) {
                if (i !== 0 || (currentScenario.yMin !== null && currentScenario.yMin >= 0)) {
                    ctx.fillText(i, originX - 20, originY - i * scaleY + 5);
                }
            }
            
            // Dibujar la recta
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            // Calcular l√≠mites de la recta seg√∫n restricciones
            const lineXMin = currentScenario.xMin !== null ? currentScenario.xMin : -12;
            const lineXMax = currentScenario.xMax || 12;
            
            const x1 = lineXMin;
            const y1 = slope * x1 + yIntercept;
            const x2 = lineXMax;
            const y2 = slope * x2 + yIntercept;
            
            ctx.moveTo(originX + x1 * scaleX, originY - y1 * scaleY);
            ctx.lineTo(originX + x2 * scaleX, originY - y2 * scaleY);
            ctx.stroke();
            
            // Dibujar puntos seleccionados y tri√°ngulo
            if (selectedPoints.length > 0) {
                selectedPoints.forEach((point, index) => {
                    drawPoint(point.x, point.y, index + 1, originX, originY, scaleX, scaleY);
                    drawDashedLinesToAxes(point.x, point.y, originX, originY, scaleX, scaleY);
                });
                
                if (selectedPoints.length === 2) {
                    drawTriangle(selectedPoints[0], selectedPoints[1], originX, originY, scaleX, scaleY);
                }
            }
            
            // Mostrar el valor de la pendiente y ecuaci√≥n al FINAL para que quede por encima
            if (showSlopeValue) {
                ctx.font = 'bold 16px Arial';
                
                // Construir la ecuaci√≥n de la recta seg√∫n el escenario
                let equation = '';
                if (yIntercept >= 0) {
                    equation = `${currentScenario.yVar}(${currentScenario.xVar}) = ${yIntercept.toFixed(2)} + ${slope.toFixed(2)}${currentScenario.xVar}`;
                } else {
                    equation = `${currentScenario.yVar}(${currentScenario.xVar}) = ${yIntercept.toFixed(2)} ${slope.toFixed(2)}${currentScenario.xVar}`;
                }
                
                const slopeText = `${currentScenario.slopeVar} = ${slope.toFixed(2)} ${currentScenario.slopeUnit}`;
                const maxWidth = Math.max(ctx.measureText(slopeText).width, ctx.measureText(equation).width);
                
                // Determinar posici√≥n √≥ptima seg√∫n el origen
                let boxX, boxY;
                if (currentScenario.xMin !== null && currentScenario.xMin >= 0 && 
                    currentScenario.yMin !== null && currentScenario.yMin >= 0) {
                    // Origen en esquina inferior izquierda: poner en superior derecha
                    boxX = CANVAS_WIDTH - maxWidth - 50;
                    boxY = 15;
                } else if (currentScenario.xMin !== null && currentScenario.xMin >= 0) {
                    // Origen a la izquierda: poner en superior derecha
                    boxX = CANVAS_WIDTH - maxWidth - 50;
                    boxY = 15;
                } else {
                    // Origen centrado: poner arriba a la izquierda para evitar ejes
                    boxX = 20;
                    boxY = 15;
                }
                
                // Fondo para el texto (ahora m√°s alto para dos l√≠neas)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.fillRect(boxX, boxY, maxWidth + 40, 65);
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 2;
                ctx.strokeRect(boxX, boxY, maxWidth + 40, 65);
                
                // Texto - Primera l√≠nea: pendiente
                ctx.fillStyle = '#3b82f6';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(slopeText, boxX + 20, boxY + 25);
                
                // Texto - Segunda l√≠nea: ecuaci√≥n
                ctx.fillStyle = '#059669';
                ctx.font = 'bold 14px Arial';
                ctx.fillText(equation, boxX + 20, boxY + 50);
            }
        }

        function drawArrow(x, y, width, height, direction = 'right') {
            ctx.beginPath();
            ctx.moveTo(x, y);
            if (direction === 'right') {
                ctx.lineTo(x - width, y - height);
                ctx.lineTo(x - width, y + height);
            } else if (direction === 'up') {
                ctx.lineTo(x - height, y + width);
                ctx.lineTo(x + height, y + width);
            }
            ctx.closePath();
            ctx.fillStyle = '#1e293b';
            ctx.fill();
        }

        function drawPoint(x, y, label, originX, originY, scaleX, scaleY) {
            const canvasX = originX + x * scaleX;
            const canvasY = originY - y * scaleY;
            
            ctx.fillStyle = '#ef4444';
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, 6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = '#991b1b';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.fillStyle = '#1e293b';
            ctx.font = 'bold 14px Arial';
            const pointLabel = `P${label}(${x.toFixed(1)}, ${y.toFixed(1)})`;
            ctx.fillText(pointLabel, canvasX + 10, canvasY - 10);
        }

        function drawDashedLinesToAxes(x, y, originX, originY, scaleX, scaleY) {
            const canvasX = originX + x * scaleX;
            const canvasY = originY - y * scaleY;
            
            ctx.strokeStyle = '#f59e0b';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            ctx.beginPath();
            ctx.moveTo(canvasX, canvasY);
            ctx.lineTo(canvasX, originY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(canvasX, canvasY);
            ctx.lineTo(originX, canvasY);
            ctx.stroke();
            
            ctx.setLineDash([]);
        }

        function drawTriangle(p1, p2, originX, originY, scaleX, scaleY) {
            const canvasX1 = originX + p1.x * scaleX;
            const canvasY1 = originY - p1.y * scaleY;
            const canvasX2 = originX + p2.x * scaleX;
            const canvasY2 = originY - p2.y * scaleY;
            
            ctx.strokeStyle = '#10b981';
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.moveTo(canvasX1, canvasY1);
            ctx.lineTo(canvasX2, canvasY1);
            ctx.lineTo(canvasX2, canvasY2);
            ctx.closePath();
            ctx.stroke();
            
            ctx.fillStyle = 'rgba(16, 185, 129, 0.1)';
            ctx.fill();
            
            const deltaX = Math.abs(p2.x - p1.x);
            const deltaY = Math.abs(p2.y - p1.y);
            
            ctx.fillStyle = '#059669';
            ctx.font = 'bold 14px Arial';
            
            // Calcular tama√±o del tri√°ngulo en p√≠xeles
            const triangleWidth = Math.abs(canvasX2 - canvasX1);
            const triangleHeight = Math.abs(canvasY2 - canvasY1);
            const isSmallTriangle = triangleWidth < 100 || triangleHeight < 100;
            
            // Etiqueta horizontal (Œîx)
            const midX = (canvasX1 + canvasX2) / 2;
            const deltaXText = `Œî${currentScenario.xVar} = ${deltaX.toFixed(1)} ${currentScenario.xUnit}`;
            
            if (isSmallTriangle && triangleWidth < 100) {
                // Si es muy estrecho, poner la etiqueta fuera (abajo)
                ctx.fillText(deltaXText, midX - 50, canvasY1 + 35);
            } else {
                // Normal: dentro del tri√°ngulo
                ctx.fillText(deltaXText, midX - 50, canvasY1 + 20);
            }
            
            // Etiqueta vertical (Œîy)
            const midY = (canvasY1 + canvasY2) / 2;
            const deltaYText = `Œî${currentScenario.yVar} = ${deltaY.toFixed(1)} ${currentScenario.yUnit}`;
            
            if (isSmallTriangle && triangleHeight < 100) {
                // Si es muy bajo, poner la etiqueta fuera (a la derecha)
                ctx.fillText(deltaYText, canvasX2 + 15, midY);
            } else {
                // Normal: pegada al lado derecho
                ctx.fillText(deltaYText, canvasX2 + 10, midY);
            }
            
            // Dibujar peque√±as marcas en las esquinas del tri√°ngulo para mayor claridad
            ctx.strokeStyle = '#059669';
            ctx.lineWidth = 2;
            
            // Marca esquina inferior derecha (√°ngulo recto)
            const cornerSize = 10;
            ctx.beginPath();
            ctx.moveTo(canvasX2 - cornerSize, canvasY1);
            ctx.lineTo(canvasX2 - cornerSize, canvasY1 - cornerSize);
            ctx.lineTo(canvasX2, canvasY1 - cornerSize);
            ctx.stroke();
        }

        function getMousePos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = CANVAS_WIDTH / rect.width;
            const scaleY = CANVAS_HEIGHT / rect.height;
            
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        canvas.addEventListener('click', function(e) {
            if (selectedPoints.length >= 2) return;
            
            const pos = getMousePos(e);
            
            // Calcular origen y escalas seg√∫n restricciones
            let originX, originY, scaleX, scaleY;
            
            if (currentScenario.xMin !== null && currentScenario.xMin >= 0 && 
                currentScenario.yMin !== null && currentScenario.yMin >= 0) {
                originX = 60;
                originY = CANVAS_HEIGHT - 60;
                scaleX = (CANVAS_WIDTH - 80) / 10;
                scaleY = (CANVAS_HEIGHT - 80) / 10;
            } else if (currentScenario.xMin !== null && currentScenario.xMin >= 0) {
                originX = 60;
                originY = ORIGIN_Y;
                scaleX = (CANVAS_WIDTH - 80) / 10;
                scaleY = SCALE;
            } else if (currentScenario.yMin !== null && currentScenario.yMin >= 0) {
                originX = ORIGIN_X;
                originY = CANVAS_HEIGHT - 60;
                scaleX = SCALE;
                scaleY = (CANVAS_HEIGHT - 80) / 10;
            } else {
                originX = ORIGIN_X;
                originY = ORIGIN_Y;
                scaleX = SCALE;
                scaleY = SCALE;
            }
            
            const x = (pos.x - originX) / scaleX;
            const y = -(pos.y - originY) / scaleY;
            
            // Verificar que el punto est√© dentro del dominio v√°lido
            if (currentScenario.xMin !== null && x < currentScenario.xMin) return;
            if (currentScenario.yMin !== null && y < currentScenario.yMin) return;
            
            const expectedY = slope * x + yIntercept;
            const distance = Math.abs(y - expectedY);
            
            if (distance < 0.5) {
                const roundedX = Math.round(x * 2) / 2;
                const exactY = slope * roundedX + yIntercept;
                
                // Verificar nuevamente que el punto est√© en el dominio v√°lido
                if (currentScenario.xMin !== null && roundedX < currentScenario.xMin) return;
                if (currentScenario.yMin !== null && exactY < currentScenario.yMin) return;
                
                selectedPoints.push({ x: roundedX, y: exactY });
                drawGraph();
                updatePointInfo();
                
                if (selectedPoints.length === 2) {
                    document.getElementById('inputPanel').style.display = 'block';
                    document.getElementById('slopeInput').focus();
                }
            }
        });

        function updatePointInfo() {
            document.getElementById('pointCount').textContent = `${selectedPoints.length} / 2`;
            
            if (selectedPoints.length >= 1) {
                const p1 = selectedPoints[0];
                document.getElementById('point1Info').style.display = 'flex';
                document.getElementById('point1Text').textContent = 
                    `(${p1.x.toFixed(1)} ${currentScenario.xUnit}, ${p1.y.toFixed(1)} ${currentScenario.yUnit})`;
            } else {
                document.getElementById('point1Info').style.display = 'none';
            }
            
            if (selectedPoints.length === 2) {
                const p1 = selectedPoints[0];
                const p2 = selectedPoints[1];
                document.getElementById('point2Info').style.display = 'flex';
                document.getElementById('point2Text').textContent = 
                    `(${p2.x.toFixed(1)} ${currentScenario.xUnit}, ${p2.y.toFixed(1)} ${currentScenario.yUnit})`;
                
                const deltaX = Math.abs(p2.x - p1.x);
                const deltaY = Math.abs(p2.y - p1.y);
                
                document.getElementById('deltaXLabel').textContent = `Œî${currentScenario.xVar}:`;
                document.getElementById('deltaYLabel').textContent = `Œî${currentScenario.yVar}:`;
                
                document.getElementById('deltaInfo').style.display = 'flex';
                document.getElementById('deltaX').textContent = `${deltaX.toFixed(2)} ${currentScenario.xUnit}`;
                document.getElementById('deltaY').textContent = `${deltaY.toFixed(2)} ${currentScenario.yUnit}`;
            } else {
                document.getElementById('point2Info').style.display = 'none';
                document.getElementById('deltaInfo').style.display = 'none';
            }
        }

        function checkAnswer() {
            const userAnswer = parseFloat(document.getElementById('slopeInput').value);
            
            if (isNaN(userAnswer)) {
                alert('Por favor, introduce un valor num√©rico');
                return;
            }
            
            const p1 = selectedPoints[0];
            const p2 = selectedPoints[1];
            
            const deltaX = p2.x - p1.x;
            const deltaY = p2.y - p1.y;
            const calculatedSlope = deltaY / deltaX;
            
            const isCorrect = Math.abs(userAnswer - calculatedSlope) < 0.05;
            
            // Construir la ecuaci√≥n de la recta
            let equation = '';
            if (yIntercept >= 0) {
                equation = `${currentScenario.yVar}(${currentScenario.xVar}) = ${yIntercept.toFixed(2)} + ${slope.toFixed(2)}${currentScenario.xVar}`;
            } else {
                equation = `${currentScenario.yVar}(${currentScenario.xVar}) = ${yIntercept.toFixed(2)} ${slope.toFixed(2)}${currentScenario.xVar}`;
            }
            
            // Activar visualizaci√≥n de la pendiente en el gr√°fico
            showSlopeValue = true;
            drawGraph();
            
            const resultPanel = document.getElementById('resultPanel');
            resultPanel.className = 'result-panel show';
            resultPanel.classList.add(isCorrect ? 'result-correct' : 'result-incorrect');
            
            const xVar = currentScenario.xVar;
            const yVar = currentScenario.yVar;
            const slopeVar = currentScenario.slopeVar;
            const xUnit = currentScenario.xUnit;
            const yUnit = currentScenario.yUnit;
            const slopeUnit = currentScenario.slopeUnit;
            
            let html = `
                <div class="result-title">${isCorrect ? '‚úÖ ¬°Correcto!' : '‚ùå Incorrecto'}</div>
                <div class="calculation">
                    <div class="step-label">F√≥rmula de la ${currentScenario.slopeName}:</div>
                    <div class="math-step">
                        ${slopeVar} <span class="math-equals">=</span>
                        <div class="math-fraction">
                            <div class="math-numerator">Œî${yVar}</div>
                            <div class="math-denominator">Œî${xVar}</div>
                        </div>
                        <span class="math-equals">=</span>
                        <div class="math-fraction">
                            <div class="math-numerator">${yVar}‚ÇÇ - ${yVar}‚ÇÅ</div>
                            <div class="math-denominator">${xVar}‚ÇÇ - ${xVar}‚ÇÅ</div>
                        </div>
                    </div>
                    
                    <div class="step-label">Sustituyendo los valores:</div>
                    <div class="math-step">
                        ${slopeVar} <span class="math-equals">=</span>
                        <div class="math-fraction">
                            <div class="math-numerator">(${p2.y.toFixed(2)}) - (${p1.y.toFixed(2)})</div>
                            <div class="math-denominator">(${p2.x.toFixed(2)}) - (${p1.x.toFixed(2)})</div>
                        </div>
                    </div>
                    
                    <div class="step-label">Calculando:</div>
                    <div class="math-step">
                        ${slopeVar} <span class="math-equals">=</span>
                        <div class="math-fraction">
                            <div class="math-numerator">${deltaY.toFixed(2)}</div>
                            <div class="math-denominator">${deltaX.toFixed(2)}</div>
                        </div>
                    </div>
                    
                    <div class="final-answer">
                        ${slopeVar} = ${calculatedSlope.toFixed(2)} ${slopeUnit}
                    </div>
                </div>
            `;
            
            if (!isCorrect) {
                html += `
                    <div style="margin-top: 12px; font-size: clamp(0.9rem, 2.5vw, 1rem); line-height: 1.6;">
                        <strong>Tu respuesta:</strong> ${userAnswer.toFixed(2)} ${slopeUnit}<br>
                        <strong>Respuesta correcta:</strong> ${calculatedSlope.toFixed(2)} ${slopeUnit}
                    </div>
                `;
            }
            
            html += `
                <div style="margin-top: 15px; padding: 15px; background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%); border-radius: 10px; border: 2px solid #d97706; box-shadow: 0 4px 15px rgba(251, 191, 36, 0.4);">
                    <div style="font-size: clamp(0.85rem, 2.5vw, 0.95rem); font-weight: 600; margin-bottom: 8px; color: #78350f; text-align: center;">
                        üìê Ecuaci√≥n de la recta:
                    </div>
                    <div style="font-size: clamp(1rem, 3.5vw, 1.15rem); font-family: 'Courier New', monospace; color: #1e293b; font-weight: 700; text-align: center; background: rgba(255, 255, 255, 0.9); padding: 10px; border-radius: 6px;">
                        ${equation}
                    </div>
                </div>
            `;
            
            resultPanel.innerHTML = html;
        }

        function resetPoints() {
            selectedPoints = [];
            showSlopeValue = false;
            updatePointInfo();
            document.getElementById('inputPanel').style.display = 'none';
            document.getElementById('resultPanel').classList.remove('show');
            document.getElementById('slopeInput').value = '';
            drawGraph();
        }

        // Inicializar
        generateNewScenario();
    </script>
</body>
</html>
